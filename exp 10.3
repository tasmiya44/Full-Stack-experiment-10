
{
"name": "social-backend",
"version": "1.0.0",
"main": "server.js",
"scripts": {
"start": "node server.js",
"dev": "nodemon server.js"
},
"dependencies": {
"aws-sdk": "^2.1370.0",
"bcryptjs": "^2.4.3",
"cors": "^2.8.5",
"dotenv": "^16.0.0",
"express": "^4.18.2",
"jsonwebtoken": "^9.0.0",
"mongoose": "^7.0.0",
"multer": "^1.4.5"
},
"devDependencies": { "nodemon": "^2.0.22" }
}
PORT=5000
MONGO_URI=mongodb://localhost:27017/socialdb
JWT_ACCESS_SECRET=replace_with_access_secret
JWT_REFRESH_SECRET=replace_with_refresh_secret
AWS_ACCESS_KEY_ID=AKIA...
AWS_SECRET_ACCESS_KEY=...
AWS_REGION=us-east-1
S3_BUCKET_NAME=your-bucket-name

require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const path = require('path');


const authRoutes = require('./routes/auth');
const postsRoutes = require('./routes/posts');


const app = express();
app.use(cors());
app.use(express.json());


app.use('/api/auth', authRoutes);
app.use('/api/posts', postsRoutes);


// health
app.get('/api/health', (req, res) => res.json({ ok: true }));


const PORT = process.env.PORT || 5000;


mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })
.then(() => {
console.log('MongoDB connected');
app.listen(PORT, () => console.log('Server running on port', PORT));
})
.catch(err => console.error(err));
const AWS = require('aws-sdk');


const s3 = new AWS.S3({ region: process.env.AWS_REGION });


async function uploadBuffer({ Bucket, Key, Body, ContentType }) {
return s3.upload({ Bucket, Key, Body, ContentType }).promise();
}


module.exports = { uploadBuffer };

const mongoose = require('mongoose');


const UserSchema = new mongoose.Schema({
name: { type: String, required: true },
email: { type: String, required: true, unique: true },
passwordHash: { type: String, required: true },
bio: { type: String, default: '' },
avatarUrl: { type: String, default: '' },
refreshTokens: [{ token: String, createdAt: Date }]
}, { timestamps: true });


module.exports = mongoose.model('User', UserSchema);

const mongoose = require('mongoose');


const PostSchema = new mongoose.Schema({
content: { type: String, required: true },
mediaUrl: { type: String },
author: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }]
}, { timestamps: true });


module.exports = mongoose.model('Post', PostSchema);

const jwt = require('jsonwebtoken');
require('dotenv').config();


module.exports = function (req, res, next) {
const token = req.header('Authorization')?.replace('Bearer ', '');
if (!token) return res.status(401).json({ message: 'No auth token' });
try {
const decoded = jwt.verify(token, process.env.JWT_ACCESS_SECRET);
req.user = decoded; // { id }
next();
} catch (err) {
return res.status(401).json({ message: 'Invalid token' });
}
};

const express = require('express');
await user.save();
const access = createAccessToken({ id: user._id });
const refresh = createRefreshToken({ id: user._id });
user.refreshTokens.push({ token: refresh, createdAt: new Date() });
await user.save();
res.json({ access, refresh, user: { id: user._id, name: user.name, email: user.email } });
} catch (err) { console.error(err); res.status(500).send('Server error'); }
});


// Login
router.post('/login', async (req, res) => {
const { email, password } = req.body;
try {
const user = await User.findOne({ email });
if (!user) return res.status(400).json({ message: 'Invalid credentials' });
const isMatch = await bcrypt.compare(password, user.passwordHash);
if (!isMatch) return res.status(400).json({ message: 'Invalid credentials' });
const access = createAccessToken({ id: user._id });
const refresh = createRefreshToken({ id: user._id });
user.refreshTokens.push({ token: refresh, createdAt: new Date() });
await user.save();
res.json({ access, refresh, user: { id: user._id, name: user.name, email: user.email, avatarUrl: user.avatarUrl } });
} catch (err) { console.error(err); res.status(500).send('Server error'); }
});


// Refresh token
router.post('/refresh', async (req, res) => {
const { refresh } = req.body;
try {
if (!refresh) return res.status(400).json({ message: 'No refresh token' });
const decoded = jwt.verify(refresh, process.env.JWT_REFRESH_SECRET);
const user = await User.findById(decoded.id);
if (!user) return res.status(401).json({ message: 'Invalid refresh' });
const match = user.refreshTokens.find(r => r.token === refresh);
if (!match) return res.status(401).json({ message: 'Refresh not found' });
const access = createAccessToken({ id: user._id });
res.json({ access });
} catch (err) { console.error(err); res.status(401).json({ message: 'Invalid token' }); }
});


// Logout (revoke refresh)
router.post('/logout', async (req, res) => {
const { refresh } = req.body;
try {
if (!refresh) return res.sendStatus(200);
const decoded = jwt.decode(refresh);
if (!decoded) return res.sendStatus(200);
await User.updateOne({ _id: decoded.id }, { $pull: { refreshTokens: { token: refresh } } });
res.sendStatus(200);
} catch (err) { console.error(err); res.sendStatus(500); }
});


module.exports = router;

const express = require('express');
const router = express.Router();
const multer = require('multer');
const { uploadBuffer } = require('../config/awsS3');
const auth = require('../middleware/auth');


const Post = require('../models/Post');


const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 10 * 1024 * 1024 } });


// Create post (with optional media)
router.post('/', auth, upload.single('media'), async (req, res) => {
try {
let mediaUrl = null;
if (req.file) {
const Key = `posts/${req.user.id}/${Date.now()}_${req.file.originalname}`;
const s3res = await uploadBuffer({ Bucket: process.env.S3_BUCKET_NAME, Key, Body: req.file.buffer, ContentType: req.file.mimetype });
mediaUrl = s3res.Location;
}
const post = new Post({ content: req.body.content, mediaUrl, author: req.user.id });
await post.save();
await post.populate('author', 'name avatarUrl');
res.json(post);
} catch (err) { console.error(err); res.status(500).send('Server error'); }
});


// Get feed
router.get('/feed', auth, async (req, res) => {
try {
const posts = await Post.find().populate('author', 'name avatarUrl').sort({ createdAt: -1 }).limit(50);
res.json(posts);
} catch (err) { console.error(err); res.status(500).send('Server error'); }
});


// Like/unlike
router.post('/:id/like', auth, async (req, res) => {
try {
const post = await Post.findById(req.params.id);
if (!post) return res.status(404).json({ message: 'Post not found' });
const idx = post.likes.findIndex(id => id.toString() === req.user.id);
if (idx === -1) post.likes.push(req.user.id);
else post.likes.splice(idx, 1);
await post.save();
res.json({ likesCount: post.likes.length });
} catch (err) { console.error(err); res.status(500).send('Server error'); }
});


module.exports = router;

{
"name": "social-frontend",
"version": "1.0.0",
"private": true,
"dependencies": {
"react": "^18.2.0",
"react-dom": "^18.2.0",
"react-scripts": "5.0.1"
},
"scripts": {
"start": "react-scripts start",
"build": "react-scripts build"
}
}
<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Social Media App</title>
</head>
<body>
<div id="root"></div>
<script src="/static/js/bundle.js"></script>
</body>
</html>
const API = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';


async function request(path, options = {}) {
const headers = options.headers || {};
if (!headers['Content-Type'] && !(options.body instanceof FormData)) headers['Content-Type'] = 'application/json';
const token = localStorage.getItem('access');
if (token) headers['Authorization'] = `Bearer ${token}`;
const res = await fetch(`${API}${path}`, { ...options, headers });
if (res.status === 401) {
// try refresh
const refresh = localStorage.getItem('refresh');
if (refresh) {
const r = await fetch(`${API}/auth/refresh`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ refresh }) });
if (r.ok) {
const d = await r.json();
localStorage.setItem('access', d.access);
headers['Authorization'] = `Bearer ${d.access}`;
return fetch(`${API}${path}`, { ...options, headers });
}
}
}
return res;
}


export default { request };

import React, { useState } from 'react';


export default function AuthForm({ onAuth }) {
const [mode, setMode] = useState('login');
const [email, setEmail] = useState('');
const [pw, setPw] = useState('');
const [name, setName] = useState('');


async function submit(e) {
e.preventDefault();
const path = mode === 'login' ? '/auth/login' : '/auth/register';
const res = await fetch(`/api${path}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(mode === 'login' ? { email, password: pw } : { name, email, password: pw }) });
const data = await res.json();
if (res.ok) {
localStorage.setItem('access', data.access || data.token || '');
if (data.refresh) localStorage.setItem('refresh', data.refresh);
localStorage.setItem('user', JSON.stringify(data.user));
onAuth(data.user);
} else alert(data.message || 'Auth failed');
}


return (
<form onSubmit={submit} className="p-3 border rounded">
{mode === 'register' && <input value={name} onChange={e => setName(e.target.value)} placeholder="Name" className="w-full p-2 my-1" />}
<input value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" className="w-full p-2 my-1" />
<input type="password" value={pw} onChange={e => setPw(e.target.value)} placeholder="Password" className="w-full p-2 my-1" />
<div className="flex gap-2 mt-2">
<button className="px-3 py-1 border rounded">{mode === 'login' ? 'Login' : 'Register'}</button>
<button type="button" onClick={() => setMode(mode === 'login' ? 'register' : 'login')} className="px-3 py-1 border rounded">Switch</button>
</div>
</form>
);
}
import React, { useEffect, useState } from 'react';


export default function PostList({ onOpen }) {
const [posts, setPosts] = useState([]);
useEffect(() => { fetchPosts(); }, []);
async function fetchPosts() {
const res = await fetch('/api/posts/feed', { headers: { Authorization: `Bearer ${localStorage.getItem('access')}` } });
const data = await res.json();
setPosts(data);
}
return (
<div>
{posts.map(p => (
<div key={p._id} className="p-3 border my-2 rounded">
<div className="flex justify-between">
<div><strong>{p.author?.name}</strong><div className="text-sm">{new Date(p.createdAt).toLocaleString()}</div></div>
<button onClick={() => onOpen(p._id)} className="px-2 py-1 border rounded">Open</button>
</div>
<p className="mt-2">{p.content}</p>
{p.mediaUrl && <img src={p.mediaUrl} alt="media" className="mt-2 max-h-64 object-contain" />}
</div>
))}
</div>
);
}

import React, { useState } from 'react';


export default function CreatePost({ onPosted }) {
const [text, setText] = useState('');
const [file, setFile] = useState(null);


async function submit(e) {
e.preventDefault();
const form = new FormData();
form.append('content', text);
if (file) form.append('media', file);
const res = await fetch('/api/posts', { method: 'POST', body: form, headers: { Authorization: `Bearer ${localStorage.getItem('access')}` } });
if (res.ok) {
setText(''); setFile(null);
const p = await res.json();
onPosted(p);
} else {
alert('Failed to post');
}
}


return (
<form onSubmit={submit} className="p-3 border rounded mb-4">
<textarea value={text} onChange={e=>setText(e.target.value)} rows={4} className="w-full p-2 border rounded" placeholder="What's happening?" />
<input type="file" onChange={e=>setFile(e.target.files[0])} className="mt-2" />
<div className="mt-2">
<button className="px-3 py-1 border rounded">Post</button>
</div>
</form>
);
}

import React, { useState } from 'react';
import AuthForm from './components/AuthForm';
import PostList from './components/PostList';
import CreatePost from './components/CreatePost';


function App() {
const [user, setUser] = useState(JSON.parse(localStorage.getItem('user')) || null);
function handleAuth(u) { setUser(u); }
return (
<div className="min-h-screen p-6 bg-gray-50">
<header className="max-w-4xl mx-auto flex justify-between items-center mb-6">
<h1 className="text-2xl font-bold">Social Media App</h1>
<div>
{user ? (<div>{user.name} <button onClick={() => { localStorage.clear(); setUser(null); }}>Logout</button></div>) : <div>Not logged in</div>}
</div>
</header>
<main className="max-w-4xl mx-auto grid grid-cols-3 gap-6">
<section className="col-span-2">
{user && <CreatePost onPosted={()=>window.location.reload()} />}
<PostList onOpen={(id)=>alert('Open ' + id)} />
</section>
<aside>
{!user ? <AuthForm onAuth={handleAuth} /> : <div className="p-3 border rounded">Welcome, {user.name}</div>}
</aside>
</main>
</div>
);
}


export default App;

dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --production
COPY . .
ENV PORT=5000
EXPOSE 5000
CMD ["node", "server.js"]

name: Deploy to AWS
on:
push:
branches: [ main ]
jobs:
build-and-deploy-backend:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v4
- name: Login to ECR
uses: aws-actions/amazon-ecr-login@v1
- name: Build and push image
run: |
IMAGE_TAG=${{ github.sha }}
docker build -t ${{ secrets.ECR_REPO }}:${IMAGE_TAG} -f backend/Dockerfile .
docker tag ${{ secrets.ECR_REPO }}:${IMAGE_TAG} ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPO }}:${IMAGE_TAG}
docker push ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPO }}:${IMAGE_TAG}


deploy-frontend-to-s3:
runs-on: ubuntu-latest
needs: build-and-deploy-backend
steps:
- uses: actions/checkout@v4
- name: Install Node
uses: actions/setup-node@v4
with:
node-version: '18'
- name: Build frontend
run: |
cd frontend
npm ci
npm run build
- name: Deploy to S3
uses: jakejarvis/s3-sync-action@v0.6.0
with:
args: --acl public-read --delete
env:
AWS_S3_BUCKET: ${{ secrets.S3_BUCKET }}
AWS_REGION: ${{ secrets.AWS_REGION }}
AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

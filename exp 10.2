
{
  "name": "blog-backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.0.0",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^7.0.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}


## Backend — server.js

const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
require('dotenv').config();

const authRoutes = require('./routes/auth');
const postsRoutes = require('./routes/posts');

const app = express();
app.use(cors());
app.use(express.json());

app.use('/api/auth', authRoutes);
app.use('/api/posts', postsRoutes);

const PORT = process.env.PORT || 5000;

mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => {
    console.log('MongoDB connected');
    app.listen(PORT, () => console.log('Server running on port', PORT));
  })
  .catch(err => console.error(err));



## Backend — models/User.js


const mongoose = require('mongoose');

const UserSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  passwordHash: { type: String, required: true },
  bio: { type: String, default: '' },
  avatarUrl: { type: String, default: '' },
}, { timestamps: true });

module.exports = mongoose.model('User', UserSchema);


## Backend — models/Post.js

const mongoose = require('mongoose');

const PostSchema = new mongoose.Schema({
  title: { type: String, required: true },
  content: { type: String, required: true },
  author: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  tags: [{ type: String }],
  likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
}, { timestamps: true });

module.exports = mongoose.model('Post', PostSchema);

## Backend — models/Comment.js

const mongoose = require('mongoose');

const CommentSchema = new mongoose.Schema({
  post: { type: mongoose.Schema.Types.ObjectId, ref: 'Post', required: true },
  author: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  content: { type: String, required: true },
}, { timestamps: true });

module.exports = mongoose.model('Comment', CommentSchema);


## Backend — middleware/auth.js
const jwt = require('jsonwebtoken');
require('dotenv').config();

module.exports = function (req, res, next) {
  const token = req.header('Authorization')?.replace('Bearer ', '');
  if (!token) return res.status(401).json({ message: 'No auth token' });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // { id }
    next();
  } catch (err) {
    res.status(401).json({ message: 'Invalid token' });
  }
};

const express = require('express');
const router = express.Router();
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const User = require('../models/User');

// Register
router.post('/register', async (req, res) => {
  const { name, email, password } = req.body;
  try {
    let user = await User.findOne({ email });
    if (user) return res.status(400).json({ message: 'User already exists' });

    const salt = await bcrypt.genSalt(10);
    const passwordHash = await bcrypt.hash(password, salt);

    user = new User({ name, email, passwordHash });
    await user.save();

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, user: { id: user._id, name: user.name, email: user.email } });
  } catch (err) {
    console.error(err);
    res.status(500).send('Server error');
  }
});

router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: 'Invalid credentials' });

    const isMatch = await bcrypt.compare(password, user.passwordHash);
    if (!isMatch) return res.status(400).json({ message: 'Invalid credentials' });

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, user: { id: user._id, name: user.name, email: user.email, bio: user.bio, avatarUrl: user.avatarUrl } });
  } catch (err) {
    console.error(err);
    res.status(500).send('Server error');
  }
});

module.exports = router;

## Backend — routes/posts.js
const express = require('express');
const router = express.Router();
const auth = require('../middleware/auth');

const Post = require('../models/Post');
const Comment = require('../models/Comment');
const User = require('../models/User');

// Create post
router.post('/', auth, async (req, res) => {
  const { title, content, tags } = req.body;
  try {
    const post = new Post({ title, content, author: req.user.id, tags: tags || [] });
    await post.save();
    res.json(post);
  } catch (err) {
    console.error(err);
    res.status(500).send('Server error');
  }
});

// Get all posts (with basic author)
router.get('/', async (req, res) => {
  try {
    const posts = await Post.find().populate('author', 'name avatarUrl').sort({ createdAt: -1 });
    res.json(posts);
  } catch (err) {
    console.error(err);
    res.status(500).send('Server error');
  }
});

// Get single post with comments
router.get('/:id', async (req, res) => {
  try {
    const post = await Post.findById(req.params.id).populate('author', 'name avatarUrl');
    if (!post) return res.status(404).json({ message: 'Post not found' });

    const comments = await Comment.find({ post: post._id }).populate('author', 'name avatarUrl').sort({ createdAt: 1 });
    res.json({ post, comments });
  } catch (err) {
    console.error(err);
    res.status(500).send('Server error');
  }
});

// Add comment
router.post('/:id/comments', auth, async (req, res) => {
  const { content } = req.body;
  try {
    const post = await Post.findById(req.params.id);
    if (!post) return res.status(404).json({ message: 'Post not found' });

    const comment = new Comment({ post: post._id, author: req.user.id, content });
    await comment.save();
    await comment.populate('author', 'name avatarUrl');
    res.json(comment);
  } catch (err) {
    console.error(err);
    res.status(500).send('Server error');
  }
});

// Get profile
router.get('/profile/:userId', async (req, res) => {
  try {
    const user = await User.findById(req.params.userId).select('-passwordHash');
    if (!user) return res.status(404).json({ message: 'User not found' });
    const posts = await Post.find({ author: user._id }).sort({ createdAt: -1 });
    res.json({ user, posts });
  } catch (err) {
    console.error(err);
    res.status(500).send('Server error');
  }
});

module.exports = router;

{
  "name": "blog-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build"
  }

<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Blog Platform</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>

import React, { useState, useEffect } from 'react';

const API = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

function App() {
  const [token, setToken] = useState(localStorage.getItem('token'));
  const [user, setUser] = useState(JSON.parse(localStorage.getItem('user')) || null);
  const [posts, setPosts] = useState([]);
  const [viewPost, setViewPost] = useState(null);

  // Auth forms
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');

  // Create post
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');

  useEffect(() => { fetchPosts(); }, []);

  function authHeaders() {
    return token ? { Authorization: `Bearer ${token}` } : {};
  }

  async function fetchPosts() {
    const res = await fetch(`${API}/posts`);
    const data = await res.json();
    setPosts(data);
  }

  async function handleRegister(e) {
    e.preventDefault();
    const res = await fetch(`${API}/auth/register`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, email, password })
    });
    const data = await res.json();
    if (data.token) { localStorage.setItem('token', data.token); localStorage.setItem('user', JSON.stringify(data.user)); setToken(data.token); setUser(data.user); }
    else alert(data.message || 'Register failed');
  }

  async function handleLogin(e) {
    e.preventDefault();
    const res = await fetch(`${API}/auth/login`, {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    const data = await res.json();
    if (data.token) { localStorage.setItem('token', data.token); localStorage.setItem('user', JSON.stringify(data.user)); setToken(data.token); setUser(data.user); }
    else alert(data.message || 'Login failed');
  }

  function logout() { localStorage.removeItem('token'); localStorage.removeItem('user'); setToken(null); setUser(null); }

  async function createPost(e) {
    e.preventDefault();
    const res = await fetch(`${API}/posts`, {
      method: 'POST', headers: { 'Content-Type': 'application/json', ...authHeaders() },
      body: JSON.stringify({ title, content })
    });
    if (res.ok) { setTitle(''); setContent(''); fetchPosts(); }
    else alert('Unable to create post');
  }

  async function openPost(id) {
    const res = await fetch(`${API}/posts/${id}`);
    const data = await res.json();
    setViewPost(data);
  }

  async function addComment(e, postId, commentTextSetter) {
    e.preventDefault();
    const content = commentTextSetter.value;
    if (!content) return;
    const res = await fetch(`${API}/posts/${postId}/comments`, {
      method: 'POST', headers: { 'Content-Type': 'application/json', ...authHeaders() },
      body: JSON.stringify({ content })
    });
    if (res.ok) {
      const newComment = await res.json();
      setViewPost(prev => ({ ...prev, comments: [...prev.comments, newComment] }));
      commentTextSetter.set('');
    } else alert('Failed to add comment');
  }

  return (
    <div className="min-h-screen bg-gray-50 p-6">
      <header className="max-w-4xl mx-auto mb-6 flex justify-between items-center">
        <h1 className="text-2xl font-bold">Blog Platform</h1>
        <div>
          {user ? (
            <div className="flex items-center gap-4">
              <div>{user.name}</div>
              <button onClick={logout} className="px-3 py-1 border rounded">Logout</button>
            </div>
          ) : (
            <div className="text-sm">Please login / register</div>
          )}
        </div>
      </header>

      <main className="max-w-4xl mx-auto grid grid-cols-3 gap-6">
        <section className="col-span-2">
          <div className="mb-4">
            <h2 className="font-semibold">Create Post</h2>
            {!user ? <div className="text-sm text-red-600">Login to create posts</div> : (
              <form onSubmit={createPost} className="space-y-2">
                <input value={title} onChange={e => setTitle(e.target.value)} placeholder="Title" className="w-full p-2 border rounded" />
                <textarea value={content} onChange={e => setContent(e.target.value)} placeholder="Content" className="w-full p-2 border rounded" rows={4} />
                <button className="px-4 py-2 rounded bg-blue-600 text-white">Post</button>
              </form>
            )}
          </div>

          <div>
            <h2 className="font-semibold">Posts</h2>
            {posts.map(p => (
              <article key={p._id} className="p-3 border rounded my-2">
                <div className="flex justify-between">
                  <div>
                    <h3 className="font-bold">{p.title}</h3>
                    <div className="text-sm">by {p.author?.name} • {new Date(p.createdAt).toLocaleString()}</div>
                  </div>
                  <div>
                    <button onClick={() => openPost(p._id)} className="px-2 py-1 border rounded">Open</button>
                  </div>
                </div>
              </article>
            ))}
          </div>
        </section>

        <aside>
          <div className="mb-4 p-3 border rounded">
            <h3 className="font-semibold">Auth</h3>
            {!user ? (
              <div>
                <form onSubmit={handleLogin} className="space-y-2">
                  <input value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" className="w-full p-2 border rounded" />
                  <input type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder="Password" className="w-full p-2 border rounded" />
                  <button className="px-3 py-1 border rounded">Login</button>
                </form>

                <hr className="my-2" />

                <form onSubmit={handleRegister} className="space-y-2">
                  <input value={name} onChange={e => setName(e.target.value)} placeholder="Name" className="w-full p-2 border rounded" />
                  <input value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" className="w-full p-2 border rounded" />
                  <input type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder="Password" className="w-full p-2 border rounded" />
                  <button className="px-3 py-1 border rounded">Register</button>
                </form>
              </div>
            ) : (
              <div>
                <div className="font-medium">{user.name}</div>
                <div className="text-sm">{user.email}</div>
              </div>
            )}
          </div>

          {viewPost && (
            <div className="p-3 border rounded">
              <h3 className="font-semibold">Viewing: {viewPost.post.title}</h3>
              <div className="text-sm mb-2">by {viewPost.post.author?.name}</div>
              <p className="mb-3">{viewPost.post.content}</p>

              <div className="mb-2">
                <h4 className="font-medium">Comments</h4>
                {viewPost.comments.map(c => (
                  <div key={c._id} className="border-t py-2">
                    <div className="text-sm font-medium">{c.author?.name} <span className="text-xs text-gray-500">• {new Date(c.createdAt).toLocaleString()}</span></div>
                    <div>{c.content}</div>
                  </div>
                ))}

                {user ? (
                  <CommentForm postId={viewPost.post._id} onAdd={(newC) => setViewPost(prev => ({ ...prev, comments: [...prev.comments, newC] }))} token={token} />
                ) : <div className="text-sm text-gray-500">Login to comment</div>}
              </div>
            </div>
          )}
        </aside>
      </main>
    </div>
  );
}

function CommentForm({ postId, onAdd, token }) {
  const [text, setText] = useState('');
  async function submit(e) {
    e.preventDefault();
    if (!text) return;
    const res = await fetch(`http://localhost:5000/api/posts/${postId}/comments`, {
      method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
      body: JSON.stringify({ content: text })
    });
    if (res.ok) {
      const comment = await res.json();
      onAdd(comment);
      setText('');
    } else {
      alert('Failed to add comment');
    }
  }
  return (
    <form onSubmit={submit} className="mt-2">
      <textarea value={text} onChange={e => setText(e.target.value)} rows={3} className="w-full p-2 border rounded" placeholder="Write a comment..." />
      <button className="mt-2 px-3 py-1 rounded border">Comment</button>
    </form>
  );
}
